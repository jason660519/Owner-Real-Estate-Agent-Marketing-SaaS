# 資料庫選型建議書

## 問題分析

### 原始方案：使用 ClickHouse 儲存謄本 PDF 解析後的 JSON

**ClickHouse 的特性：**
- ✅ 列式儲存，適合分析型查詢
- ✅ 高壓縮率，節省儲存空間
- ✅ 批量寫入效能優秀
- ❌ **更新操作複雜**：需要 ALTER TABLE 或重新插入整行
- ❌ **關聯查詢效能較差**：JOIN 操作不如關聯式資料庫
- ❌ **JSON 查詢能力有限**：不如 PostgreSQL 的 JSONB 強大
- ❌ **單筆查詢效能較弱**：適合聚合查詢，不適合快速讀取單筆完整資料

### 專案實際需求

1. **謄本資料儲存**：PDF 解析後的 JSON 資料
2. **資料關聯**：需要與物件照片、屋主資料建立關聯
3. **資料更新**：解析結果可能需要人工修正
4. **快速查詢**：生成物件廣告頁面需要快速讀取完整物件資訊
5. **分析查詢**：財務報表、統計分析（次要需求）

## 建議方案

### 方案一：PostgreSQL 作為主資料庫（推薦）

**適用場景：**
- 日常的物件資料管理
- 謄本 JSON 資料儲存與查詢
- 物件與照片的關聯查詢
- 生成物件廣告頁面

**優勢：**
1. **JSONB 強大功能**：
   ```sql
   -- 儲存謄本解析結果
   CREATE TABLE building_transcripts (
       id SERIAL PRIMARY KEY,
       property_id INTEGER REFERENCES properties(id),
       transcript_data JSONB,  -- 完整的謄本解析 JSON
       created_at TIMESTAMP DEFAULT NOW()
   );
   
   -- 強大的 JSON 查詢
   SELECT transcript_data->>'address' as address,
          transcript_data->>'total_area' as area
   FROM building_transcripts
   WHERE transcript_data @> '{"district": "信義區"}';
   
   -- JSON 索引支援
   CREATE INDEX idx_transcript_address ON building_transcripts 
   USING GIN (transcript_data jsonb_path_ops);
   ```

2. **優秀的關聯查詢**：
   ```sql
   -- 查詢物件完整資訊（包含照片）
   SELECT 
       p.*,
       json_agg(ph.*) as photos,
       bt.transcript_data as building_info
   FROM properties p
   LEFT JOIN photos ph ON ph.property_id = p.id
   LEFT JOIN building_transcripts bt ON bt.property_id = p.id
   WHERE p.id = 123;
   ```

3. **ACID 事務支援**：資料更新、修正操作安全可靠

4. **單筆查詢效能佳**：適合生成廣告頁面

### 方案二：PostgreSQL + ClickHouse 混合架構（進階）

**架構設計：**
- **PostgreSQL**：主資料庫（OLTP）
  - 儲存所有業務資料
  - 處理日常查詢與更新
  
- **ClickHouse**：分析資料庫（OLAP）
  - 從 PostgreSQL 定期同步資料
  - 僅用於財務報表、統計分析

**資料同步流程：**
```
PostgreSQL (主資料庫)
    ↓ (定期 ETL)
ClickHouse (分析資料庫)
    ↓
財務報表查詢
```

**適用場景：**
- 需要複雜的財務分析
- 跨物件統計查詢
- 市場趨勢分析

**注意事項：**
- 初期可以只用 PostgreSQL
- 當分析需求增加時再引入 ClickHouse
- 需要額外的 ETL 流程維護成本

## 資料庫架構設計建議

### PostgreSQL 核心資料表

```sql
-- 1. 屋主資料表
CREATE TABLE owners (
    id SERIAL PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    phone VARCHAR(20) UNIQUE NOT NULL,
    email VARCHAR(255),
    created_at TIMESTAMP DEFAULT NOW()
);

-- 2. 物件資料表
CREATE TABLE properties (
    id SERIAL PRIMARY KEY,
    owner_id INTEGER REFERENCES owners(id),
    address TEXT NOT NULL,
    district VARCHAR(50),
    property_type VARCHAR(50),
    status VARCHAR(20) DEFAULT 'draft', -- draft, listed, rented
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

-- 3. 謄本資料表（使用 JSONB）
CREATE TABLE building_transcripts (
    id SERIAL PRIMARY KEY,
    property_id INTEGER REFERENCES properties(id),
    transcript_data JSONB NOT NULL,  -- 完整的謄本解析 JSON
    parsing_confidence FLOAT,  -- 解析信心度
    needs_review BOOLEAN DEFAULT FALSE,  -- 是否需要人工審核
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

-- 4. 照片資料表
CREATE TABLE property_photos (
    id SERIAL PRIMARY KEY,
    property_id INTEGER REFERENCES properties(id),
    minio_path VARCHAR(500) NOT NULL,  -- MinIO 儲存路徑
    photo_order INTEGER,  -- 照片順序
    is_primary BOOLEAN DEFAULT FALSE,  -- 是否為主圖
    created_at TIMESTAMP DEFAULT NOW()
);

-- 5. 廣告頁面資料表
CREATE TABLE property_listings (
    id SERIAL PRIMARY KEY,
    property_id INTEGER REFERENCES properties(id),
    listing_url VARCHAR(500) UNIQUE,
    template_id VARCHAR(50),
    generated_content JSONB,  -- 生成的文案內容
    published_at TIMESTAMP,
    created_at TIMESTAMP DEFAULT NOW()
);

-- 建立索引
CREATE INDEX idx_transcript_property ON building_transcripts(property_id);
CREATE INDEX idx_transcript_json ON building_transcripts USING GIN (transcript_data);
CREATE INDEX idx_photos_property ON property_photos(property_id);
CREATE INDEX idx_listings_property ON property_listings(property_id);
```

### 查詢範例

```sql
-- 生成物件廣告頁面所需的完整資料
SELECT 
    p.id,
    p.address,
    p.district,
    p.property_type,
    o.name as owner_name,
    o.phone as owner_phone,
    bt.transcript_data as building_info,
    json_agg(
        json_build_object(
            'id', ph.id,
            'url', ph.minio_path,
            'order', ph.photo_order,
            'is_primary', ph.is_primary
        ) ORDER BY ph.photo_order
    ) as photos,
    pl.listing_url,
    pl.generated_content
FROM properties p
JOIN owners o ON o.id = p.owner_id
LEFT JOIN building_transcripts bt ON bt.property_id = p.id
LEFT JOIN property_photos ph ON ph.property_id = p.id
LEFT JOIN property_listings pl ON pl.property_id = p.id
WHERE p.id = $1
GROUP BY p.id, o.id, bt.id, pl.id;
```

## 實施建議

### 階段一：初期開發（推薦）
- ✅ 使用 **PostgreSQL** 作為唯一資料庫
- ✅ 使用 JSONB 儲存謄本解析結果
- ✅ 建立完整的關聯資料表結構
- ✅ 實作物件廣告頁面生成功能

### 階段二：規模擴展（可選）
- 當財務分析需求增加時
- 引入 **ClickHouse** 作為分析資料庫
- 建立 ETL 流程同步資料
- 將分析型查詢遷移至 ClickHouse

## 總結

**建議採用 PostgreSQL 作為主資料庫**，原因：

1. ✅ **完美支援 JSON 儲存與查詢**：JSONB 類型提供強大的查詢能力
2. ✅ **優秀的關聯查詢效能**：物件、照片、屋主資料的 JOIN 操作高效
3. ✅ **適合頻繁更新**：支援 ACID 事務，資料修正操作簡單
4. ✅ **單筆查詢效能佳**：生成廣告頁面時能快速讀取完整資料
5. ✅ **生態系統完整**：與 Expo、Django、Rasa 等技術棧整合容易

**ClickHouse 僅建議在以下情況使用：**
- 需要大規模財務報表分析
- 跨物件統計查詢需求增加
- 資料量達到數百萬筆以上

**初期專案建議：先使用 PostgreSQL，待需求明確後再考慮引入 ClickHouse。**
